'''
    File name      : verilog_to_blif_converter_tau17.py
    Author         : Jinwook Jung (jinwookjungs@gmail.com)
    Created on     : Sat 05 Aug 2017 02:35:14 PM KST
    Last modified  : 2017-08-07 14:44:16
    Description    : Provides BlifConverter class for TAU'17 benchmarks.
'''

from __future__ import print_function
from time import gmtime, strftime
import sys


class BlifConverter(object):
    """ Blif netlist generator. """
    def __init__(self):
        self.__circuit = None
        self._inputs   = list()
        self._outputs  = list()
        self._gates    = list()
        self._assigns  = list()
        self._arrivals = list()
        self._reqtime  = list()

    def read_verilog(self, src):
        """ Reading the source verilog file. """
        lines = [x.rstrip() for x in open(src)]

        for line in lines:
            # if current line is blank or a comment:
            if line == '' or line.startswith('//'): 
                continue

            tokens = line.split()
            if tokens[0] == 'wire':
                continue
            elif tokens[0] == 'module':
                self._circuit = tokens[1]
            elif tokens[0] == 'input':
                self._inputs.append( [pin[:-1] for pin in tokens[1:]] )
            elif tokens[0] == 'output':
                self._outputs.append( [pin[:-1] for pin in tokens[1:]] )
            elif tokens[0] == 'assign':
                if tokens[3] not in ("1'b0;", "1'b1;"):
                    sys.stderr.write("(E) Unsupported netlist: %s" % line)
                    sys.exit(-1)
                self._assigns.append( [tokens[1], tokens[3]])
            elif tokens.__len__() > 3:    # gate definitions
                gate_type = tokens[0] # string
                pins = tokens[3:-1] # list
                self._gates.append( [gate_type, pins] )

    def read_timing(self, asserts):
        """ Reading timing asserions. """

        lines = [x.rstrip() for x in open(asserts)]
        for line in lines:
            tokens = line.split()
            if tokens[0] == 'at':
                input_name, arrtime_r, arrtime_f = tokens[1], tokens[2], tokens[3]
                self._arrivals.append( [input_name, arrtime_r, arrtime_f] )
            if tokens[0] == 'rat':
                output_name, reqtime_r, reqtime_f = tokens[1], tokens[2], tokens[3]
                self._reqtime.append( [output_name, reqtime_r, reqtime_f] )

    def write_blif(self, dest):
        with open(dest, 'w') as f:
            f.write("# Generated by verilog_to_blif_converter_tau17.py, %s\n"
                    % (strftime("%Y-%m-%d %H:%M:%S", gmtime())))
            f.write(".model %s\n\n" % (self._circuit))
            self._print_ports("inputs", self._inputs, f)
            self._print_ports("outputs", self._outputs, f)
            self._print_arrivals(self._arrivals, f)
            self._print_reqtime(self._reqtime, f)
            self._print_assigns(self._assigns, f)
            self._print_gates(self._gates, f)
            f.write(".end\n")

    def _print_ports(self, port_type, port_list, f):
        """ Print port definition. """
        # Flatten lists
        ports = [port for sublist in port_list for port in sublist]
        f.write(".%s " % (port_type))
        f.write(" ".join(ports))
        f.write("\n")

    def _print_arrivals(self, arrivals_list, f):
        for arr in arrivals_list:
            f.write(".input_arrival %s %s %s\n" % (arr[0], arr[1], arr[2]))

    def _print_reqtime(self, reqtime_list, f):
        for arr in reqtime_list:
            f.write(".output_required %s %s %s\n" % (arr[0], arr[1], arr[2]))

    def _print_assigns(self, assign_list, f):
        f.write("\n# Assigns\n")
        for assign in assign_list:
            if assign[1] == "1'b0;":
                f.write(".gate _const0_ z=%s\n" % assign[0])
            else:
                f.write(".gate _const1_ z=%s\n" % assign[0])

    def _print_gates(self, gate_list, f, inv_name=("INV_X1", "A", "ZN")):
        def extract_pin_and_net(token):
            # token should be of .PIN(NET)
            # replace .,() with blank
            for c in ('.', ',', '(', ')'):
                token = token.replace(c, ' ')

            token = token.strip().split()
            pin, net = token[0], token[1]
            return pin, net

        f.write("\n# Gates\n")
        for gate in gate_list:
            ref_name = gate[0].upper()

            if ref_name.startswith('DFF') \
               or ref_name.startswith('SDFF') \
               or ref_name.startswith('FFLOPD') \
               or ref_name.startswith('MS'):
                q, qn, d = (None,)*3
                for pin in gate[1]:
                    pin_name, net_name = extract_pin_and_net(pin)
                    if pin_name.upper() == 'O': q = net_name
                    elif pin_name.upper() == 'Q': q = net_name
                    elif pin_name.upper() == 'QN': qn = net_name
                    elif pin_name.upper() == 'D': d = net_name

                if q is not None and qn is not None:
                    # Both Q and QN exist
                    f.write(".latch %s %s\n" % (d, q))
                    f.write(".gate %s %s=%s %s=%s\n" \
                            % (inv_name[0], inv_name[2], qn, inv_name[1], q))

                elif q is not None:
                    # Only Q exists
                    f.write(".latch %s %s\n" % (d, q))

                elif qn is not None:
                    # Only QN exists
                    f.write(".latch %s _%s\n" % (d, qn))
                    f.write(".gate %s %s=%s %s=_%s\n" \
                            % (inv_name[0], inv_name[2], qn, inv_name[1], qn))

            elif ref_name.startswith('HA'):
                f.write(".gate AND2_X1 ")
                for pin in gate[1]:
                    pin_name, net_name = extract_pin_and_net(pin)
                    if pin_name.upper() == 'A':
                        f.write("A1=%s " % (net_name))  
                    elif pin_name.upper() == 'B':
                        f.write("A2=%s " % (net_name))  
                    elif pin_name.upper() == 'CO':
                        f.write("ZN=%s " % (net_name))  
                f.write("\n")
                f.write(".gate XOR2_X1 ")
                for pin in gate[1]:
                    pin_name, net_name = extract_pin_and_net(pin)
                    if pin_name.upper() == 'A':
                        f.write("A=%s " % (net_name))  
                    elif pin_name.upper() == 'B':
                        f.write("B=%s " % (net_name))  
                    elif pin_name.upper() == 'S':
                        f.write("Z=%s " % (net_name))  
                f.write("\n")

            elif ref_name.startswith('VCC'):
                pin_name, net_name = extract_pin_and_net(gate[1][0])
                f.write(".gate one o=%s\n" % (net_name))

            else:
                f.write(".gate %s " % (gate[0]))
                # pins
                for pin in gate[1]:
                    pin_name, net_name = extract_pin_and_net(pin)
                    f.write("%s=%s " % (pin_name, net_name))  
                f.write("\n")

